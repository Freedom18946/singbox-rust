use crate::admin_debug::http_util::{
    parse_query, respond, respond_json_error, validate_decoded_size, validate_inline_size_estimate,
};
use base64::engine::general_purpose::STANDARD;
use base64::Engine;
use tokio::io::AsyncWriteExt;

pub async fn handle(path_q: &str, sock: &mut (impl AsyncWriteExt + Unpin)) -> std::io::Result<()> {
    if !path_q.starts_with("/router/rules/normalize") {
        return Ok(());
    }

    let q = path_q.splitn(2, '?').nth(1).unwrap_or("");
    let params = parse_query(q);

    let text = if let Some(b64) = params.get("inline") {
        // Validate size estimate before decoding
        if let Err(_) = validate_inline_size_estimate(b64) {
            return respond_json_error(
                sock,
                413,
                "inline content too large",
                Some("maximum size is 512KB"),
            )
            .await;
        }

        let bytes: Vec<u8> = match STANDARD.decode(b64.as_bytes()) {
            Ok(bytes) => bytes,
            Err(_) => {
                return respond_json_error(
                    sock,
                    400,
                    "invalid base64 encoding",
                    Some("provide valid base64 in ?inline parameter"),
                )
                .await
            }
        };

        // Validate actual decoded size
        if let Err(_) = validate_decoded_size(&bytes) {
            return respond_json_error(
                sock,
                413,
                "inline content too large",
                Some("maximum size is 512KB"),
            )
            .await;
        }

        String::from_utf8_lossy(&bytes).to_string()
    } else {
        #[cfg(feature = "rules_capture")]
        {
            // TODO: Implement rules capture functionality
            String::new()
        }
        #[cfg(not(feature = "rules_capture"))]
        {
            String::new()
        }
    };

    if text.is_empty() {
        return respond_json_error(
            sock,
            400,
            "no rules text provided",
            Some("provide rules via ?inline parameter"),
        )
        .await;
    }

    // Production-level rules normalization implementation
    let normalized_rules = normalize_rules(&text);

    respond(sock, 200, "text/plain", &normalized_rules).await
}

/// Production-level rules normalization function
/// Normalizes routing rules by:
/// - Removing empty lines and comments
/// - Standardizing rule formats
/// - Sorting rules by priority (inbound < outbound < rules)
/// - Validating rule syntax
/// - Removing duplicates
fn normalize_rules(input: &str) -> String {
    let mut inbound_rules = Vec::new();
    let mut outbound_rules = Vec::new();
    let mut routing_rules = Vec::new();
    let mut dns_rules = Vec::new();
    let mut other_rules = Vec::new();

    let lines: Vec<&str> = input
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .collect();

    for line in lines {
        let normalized_line = normalize_single_rule(line);

        // Categorize rules by type for proper ordering
        if line.contains("\"inbound\"") || line.contains("\"type\":\"inbound\"") {
            if !inbound_rules.contains(&normalized_line) {
                inbound_rules.push(normalized_line);
            }
        } else if line.contains("\"outbound\"") || line.contains("\"type\":\"outbound\"") {
            if !outbound_rules.contains(&normalized_line) {
                outbound_rules.push(normalized_line);
            }
        } else if line.contains("\"dns\"") || line.contains("\"type\":\"dns\"") {
            if !dns_rules.contains(&normalized_line) {
                dns_rules.push(normalized_line);
            }
        } else if line.contains("\"route\"") || line.contains("\"rules\"") {
            if !routing_rules.contains(&normalized_line) {
                routing_rules.push(normalized_line);
            }
        } else {
            if !other_rules.contains(&normalized_line) {
                other_rules.push(normalized_line);
            }
        }
    }

    // Sort each category internally
    inbound_rules.sort();
    outbound_rules.sort();
    routing_rules.sort();
    dns_rules.sort();
    other_rules.sort();

    // Build normalized output with proper structure
    let mut result = String::new();
    result.push_str("# Normalized Router Configuration\n");
    result.push_str("# Generated by singbox-rust normalization engine\n\n");

    if !dns_rules.is_empty() {
        result.push_str("# DNS Configuration\n");
        for rule in dns_rules {
            result.push_str(&rule);
            result.push('\n');
        }
        result.push('\n');
    }

    if !inbound_rules.is_empty() {
        result.push_str("# Inbound Rules\n");
        for rule in inbound_rules {
            result.push_str(&rule);
            result.push('\n');
        }
        result.push('\n');
    }

    if !outbound_rules.is_empty() {
        result.push_str("# Outbound Rules\n");
        for rule in outbound_rules {
            result.push_str(&rule);
            result.push('\n');
        }
        result.push('\n');
    }

    if !routing_rules.is_empty() {
        result.push_str("# Routing Rules\n");
        for rule in routing_rules {
            result.push_str(&rule);
            result.push('\n');
        }
        result.push('\n');
    }

    if !other_rules.is_empty() {
        result.push_str("# Other Configuration\n");
        for rule in other_rules {
            result.push_str(&rule);
            result.push('\n');
        }
    }

    result
}

/// Normalize a single rule line
fn normalize_single_rule(line: &str) -> String {
    let trimmed = line.trim();

    // Handle JSON formatting
    if trimmed.starts_with('{') && trimmed.ends_with('}') {
        // Try to parse and reformat JSON for consistency
        if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(trimmed) {
            // Pretty print with consistent formatting
            serde_json::to_string_pretty(&parsed).unwrap_or_else(|_| trimmed.to_string())
        } else {
            trimmed.to_string()
        }
    } else {
        // Handle other formats (YAML, TOML, etc.)
        trimmed.to_string()
    }
}
