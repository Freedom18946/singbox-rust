// app/src/cli/check.rs
#[cfg(feature = "check-net")]
use ipnet::{IpNet, Ipv4Net, Ipv6Net};
#[cfg(feature = "check-schema")]
use jsonschema::{Draft, JSONSchema};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::{fs, io::Write, path::Path};
use anyhow::{Context, Result};
use clap::Parser;
use sb_types::IssueCode;
use sb_config::ir::ConfigIR;
use sb_config::normalize::normalize_config;
use sb_config::minimize::{minimize_config, MinimizeAction};
use sb_config::validator::{v2, v2::pack_output};
use sb_config::validator::v2::to_ir_v1;

#[derive(clap::Args, Debug)]
pub struct CheckArgs {
    /// Config file path (YAML/JSON). Use '-' for stdin.
    #[arg(short = 'c', long = "config")]
    pub config: String,
    /// Output format: human | json | sarif
    #[arg(long, default_value = "text", value_parser = ["text", "json", "sarif"])]
    pub format: String,
    /// Treat warnings as errors
    #[arg(long)]
    pub strict: bool,
    /// Enable v1 JSON-Schema validation
    #[arg(long)]
    pub schema: bool,
    /// Dump schema: v1 (hand), v2 (schemars). Requires --schema.
    #[arg(long = "schema-dump", value_parser = ["v1","v2"], default_value="v1")]
    pub schema_dump: String,
    /// Check reference files (rules_text/rules_json/*file/*path)
    #[arg(long = "check-refs")]
    pub check_refs: bool,
    /// Max reference file size in bytes (default 256 KiB)
    #[arg(long = "max-ref-size", default_value_t = 262144)]
    pub max_ref_size: usize,
    /// Deny unknown fields (strict schema)
    #[arg(long = "deny-unknown")]
    pub deny_unknown: bool,
    /// Allow unknown fields under JSON Pointer prefixes (comma-separated), e.g. '/dns/custom,/experimental'
    #[arg(long = "allow-unknown")]
    pub allow_unknown: Option<String>,
    /// Suggest fixes in human format
    #[arg(long)]
    pub explain: bool,
    /// Enforce apiversion/kind presence and sanity (advisory unless --strict)
    #[arg(long = "enforce-apiversion")]
    pub enforce_apiversion: bool,
    /// Emit canonical JSON and SHA256 fingerprint into report (no IO)
    #[arg(long = "fingerprint")]
    pub fingerprint: bool,
    /// Root directory for resolving rules_* and *file/*path refs
    #[arg(long = "rules-dir")]
    pub rules_dir: Option<PathBuf>,
    /// Print normalized config (canonical object keys, rule reordering, deduped domain/cidr). No file writes.
    #[arg(long)]
    pub normalize: bool,
    /// Emit a JSON Patch-style autofix plan (move/replace) to make rules effective. No file writes.
    #[arg(long = "autofix-plan")]
    pub autofix_plan: bool,
    /// Print a one-line human summary (counts, ports, pools)
    #[arg(long)]
    pub summary: bool,
    /// Explainability: print why a rule is unreachable/empty (dimension-level cause)
    #[arg(long = "why")]
    pub explain_why: bool,
    /// Emit DOT graph of rule coverage/shadow edges (stdout). No file writes.
    #[arg(long = "rule-graph")]
    pub rule_graph: bool,
    /// Output minimized config (remove rules fully covered by earlier ones, keep order by specificity).
    #[arg(long = "minimize-rules")]
    pub minimize_rules: bool,
    /// Apply a JSON-Patch plan (from stdin) to the loaded config and print result to stdout. No file writes.
    #[arg(long = "apply-plan")]
    pub apply_plan: bool,
    /// Attach stable RuleID (sha256-8) to issues/graph to help mapping after reorder/minimize
    #[arg(long = "with-rule-id")]
    pub with_rule_id: bool,
    /// Compare two configs (canonical) and print rule-level diff using RuleID
    #[arg(long = "diff-config", value_names = ["OLD","NEW"])]
    pub diff_config: Vec<String>,
    /// Validate config against strong typed Schema v2 (feature: schema-v2). Automatically enabled with --deny-unknown.
    #[arg(long = "schema-v2-validate")]
    pub schema_v2: bool,
    /// Try to minimize rules (dedup/merge/etc.)
    #[arg(long = "minimize-rules", default_value_t = false)]
    pub minimize: bool,
    /// Write normalized (or minimized) config IR dump (JSON)
    #[arg(long = "write-normalized", default_value_t = false)]
    pub write_normalized: bool,
    /// Output file for --write-normalized (default: <config>.normalized.json)
    #[arg(long = "out")]
    pub out: Option<String>,
    /// Emit JSON Patch-style suggestions for negation rule fixes. No file writes.
    #[arg(long = "autofix-suggest-negation")]
    pub autofix_suggest_negation: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
enum IssueKind {
    Error,
    Warning,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
enum IssueCode {
    SchemaViolation,
    MissingField,
    InvalidType,
    InvalidPort,
    InvalidEnum,
    MutualExclusive,
    RefMissing,
    RefUnreadable,
    RefTooLarge,
    CrossRefMissing, // route.to -> proxy:<pool> not found
    UnknownField,    // deny-unknown
    TypeMismatch,    // Wrong data type for field
    OutOfRange,      // Value outside acceptable range
    DuplicateName,
    PortConflict,
    BadCIDR,
    BadDomain,
    ApiVersionMissing,
    KindMissing,
    ApiVersionUnknown,
    UnreachableRule, // 规则不可达
    ShadowedBy,      // 规则被前规则遮蔽
    EmptyRuleMatch,
    RedundantRule,
    ConflictingRule,
    ConfigRisk,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct CheckIssue {
    kind: IssueKind,
    /// RFC6901 JSON Pointer
    ptr: String,
    msg: String,
    code: IssueCode,
    #[serde(skip_serializing_if = "Option::is_none")]
    hint: Option<String>,
    /// Optional stable rule id (sha8) when SB_CHECK_RULEID=1 and ptr points to /route/rules/N
    #[serde(skip_serializing_if = "Option::is_none")]
    rule_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    members: Option<Vec<usize>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tos: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    risk: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct CheckReport {
    ok: bool,
    file: String,
    issues: Vec<CheckIssue>,
    summary: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    fingerprint: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    canonical: Option<Value>,
}

#[derive(Clone, Debug, Default)]
struct RuleKey {
    // 用于排序/去重的"特征"
    proto_w: u8,     // 0:none,1:tcp,2:udp,3:both
    dom_cnt: usize,  // 域名总数（越多越窄）
    cidr_cnt: usize, // CIDR 总数（越多越窄）
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct RuleFixOp {
    op: String, // "move" | "replace"
    #[serde(skip_serializing_if = "Option::is_none")]
    from: Option<String>,
    path: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    value: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    note: Option<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct NegationSuggestion {
    rule_index: usize,
    suggestion_type: String, // "split_allow_deny" | "remove_redundant"
    description: String,
    json_patch: Vec<serde_json::Value>,
}

fn push_err(
    issues: &mut Vec<CheckIssue>,
    code: IssueCode,
    ptr: impl Into<String>,
    msg: impl Into<String>,
    hint: Option<&str>,
) {
    issues.push(CheckIssue {
        kind: IssueKind::Error,
        code,
        ptr: ptr.into(),
        msg: msg.into(),
        hint: hint.map(|s| s.to_string()),
        rule_id: None,
        key: None,
        members: None,
        tos: None,
        risk: None,
    });
}
fn push_warn(
    issues: &mut Vec<CheckIssue>,
    code: IssueCode,
    ptr: impl Into<String>,
    msg: impl Into<String>,
    hint: Option<&str>,
) {
    issues.push(CheckIssue {
        kind: IssueKind::Warning,
        code,
        ptr: ptr.into(),
        msg: msg.into(),
        hint: hint.map(|s| s.to_string()),
        rule_id: None,
        key: None,
        members: None,
        tos: None,
        risk: None,
    });
}

#[cfg(feature = "config_guard")]
fn extract_listen_host(listen: &Value) -> Option<(String, String)> {
    match listen {
        Value::String(s) => Some((s.clone(), "/listen".into())),
        Value::Object(map) => {
            for key in ["addr", "address", "host"] {
                if let Some(val) = map.get(key).and_then(|v| v.as_str()) {
                    return Some((val.to_string(), format!("/listen/{}", key)));
                }
            }
            if let Some(val) = map.get("listen").and_then(|v| v.as_str()) {
                return Some((val.to_string(), "/listen".into()));
            }
            None
        }
        _ => None,
    }
}

#[cfg(feature = "config_guard")]
fn is_public_listen(addr: &str) -> bool {
    use std::net::{IpAddr, SocketAddr};
    let trimmed = addr.trim();
    if trimmed.is_empty() || trimmed == "*" || trimmed.starts_with(':') {
        return true;
    }
    if let Ok(sa) = trimmed.parse::<SocketAddr>() {
        return sa.ip().is_unspecified();
    }
    if let Ok(ip) = trimmed.parse::<IpAddr>() {
        return ip.is_unspecified();
    }
    if trimmed.starts_with('[') && trimmed.contains(']') {
        if let Some(end) = trimmed.find(']') {
            let inner = &trimmed[1..end];
            if let Ok(ip) = inner.parse::<IpAddr>() {
                return ip.is_unspecified();
            }
        }
    }
    if let Some(pos) = trimmed.rfind(':') {
        let host = &trimmed[..pos];
        if let Ok(ip) = host.parse::<IpAddr>() {
            return ip.is_unspecified();
        }
    }
    trimmed == "0.0.0.0" || trimmed.eq_ignore_ascii_case("::")
}

#[cfg(feature = "config_guard")]
fn socks_has_auth(inbound: &Value) -> bool {
    match inbound.get("auth") {
        Some(Value::String(s)) => {
            let lower = s.trim().to_ascii_lowercase();
            !matches!(lower.as_str(), "" | "none" | "noauth" | "anonymous")
        }
        Some(Value::Object(map)) => {
            if let Some(users) = map.get("users").and_then(|v| v.as_array()) {
                return !users.is_empty();
            }
            if let Some(method) = map.get("method").and_then(|v| v.as_str()) {
                let lower = method.trim().to_ascii_lowercase();
                return !matches!(lower.as_str(), "" | "none" | "noauth" | "anonymous");
            }
            false
        }
        Some(Value::Array(arr)) => !arr.is_empty(),
        _ => false,
    }
}

#[cfg(feature = "config_guard")]
fn push_risk_issue(
    issues: &mut Vec<CheckIssue>,
    ptr: String,
    risk_code: &str,
    msg: String,
    hint: Option<&str>,
) {
    issues.push(CheckIssue {
        kind: IssueKind::Warning,
        code: IssueCode::ConfigRisk,
        ptr,
        msg,
        hint: hint.map(|s| s.to_string()),
        rule_id: None,
        key: None,
        members: None,
        tos: None,
        risk: Some(risk_code.to_string()),
    });
}

#[cfg(feature = "config_guard")]
fn append_config_risks(doc: &Value, issues: &mut Vec<CheckIssue>) {
    if let Some(inbounds) = doc.get("inbounds").and_then(|v| v.as_array()) {
        for (idx, inbound) in inbounds.iter().enumerate() {
            let base_ptr = format!("/inbounds/{}", idx);
            if let Some(listen_val) = inbound.get("listen") {
                if let Some((raw, suffix)) = extract_listen_host(listen_val) {
                    if is_public_listen(&raw) {
                        let ptr = format!("{}{}", base_ptr, suffix);
                        let msg = format!("inbound {} listens on public interface ({})", idx, raw);
                        push_risk_issue(
                            issues,
                            ptr,
                            "PublicListen",
                            msg,
                            Some("bind to 127.0.0.1 or ::1, or enforce authentication"),
                        );
                    }
                }
            }
            let inbound_ty = inbound
                .get("type")
                .and_then(|v| v.as_str())
                .map(|s| s.to_ascii_lowercase())
                .unwrap_or_default();
            if inbound_ty == "socks" && !socks_has_auth(inbound) {
                let msg = format!("SOCKS inbound {} allows unauthenticated access", idx);
                push_risk_issue(
                    issues,
                    format!("{}/auth", base_ptr),
                    "NoAuthSocks",
                    msg,
                    Some("configure users or restrict listener address"),
                );
            }
        }
    }
    if let Some(dns) = doc.get("dns").and_then(|v| v.as_object()) {
        if dns.get("allow_public").and_then(|v| v.as_bool()) == Some(true) {
            push_risk_issue(
                issues,
                "/dns/allow_public".into(),
                "OpenResolver",
                "DNS resolver allows public recursion".into(),
                Some("disable allow_public or guard resolver behind ACL"),
            );
        }
    }

    // Check VLESS encryption=none risks
    if let Some(outbounds) = doc.get("outbounds").and_then(|v| v.as_array()) {
        for (idx, outbound) in outbounds.iter().enumerate() {
            let base_ptr = format!("/outbounds/{}", idx);
            if let Some(outbound_type) = outbound.get("type").and_then(|v| v.as_str()) {
                if outbound_type == "vless" {
                    let encryption = outbound.get("encryption").and_then(|v| v.as_str());
                    let flow = outbound.get("flow").and_then(|v| v.as_str());

                    if encryption == Some("none") || encryption.is_none() {
                        let risk_msg = if let Some(flow_val) = flow {
                            if flow_val.is_empty() {
                                format!(
                                    "VLESS outbound {} uses encryption=none without flow control",
                                    idx
                                )
                            } else {
                                format!("VLESS outbound {} uses encryption=none with flow={} - potential security risk", idx, flow_val)
                            }
                        } else {
                            format!(
                                "VLESS outbound {} uses encryption=none without flow control",
                                idx
                            )
                        };

                        push_risk_issue(
                            issues,
                            format!("{}/encryption", base_ptr),
                            "RiskyConfig",
                            risk_msg,
                            Some("Consider using encryption or ensure flow control is properly configured"),
                        );
                    }
                }
            }
        }
    }
}

/// Extract RFC6901 JSON pointer from serde error message
fn extract_json_pointer_from_error(error: &serde_json::Error) -> String {
    let error_msg = error.to_string();

    // Try to extract path information from serde error messages
    if let Some(line) = error_msg.lines().next() {
        // Look for patterns like "unknown field `field_name`"
        if line.contains("unknown field") {
            if let Some(start) = line.find('`') {
                if let Some(end) = line[start + 1..].find('`') {
                    let field_name = &line[start + 1..start + 1 + end];

                    // Try to determine context from error message
                    if line.contains("inbound") {
                        return format!("/inbounds/{}", field_name);
                    } else if line.contains("outbound") {
                        return format!("/outbounds/{}", field_name);
                    } else if line.contains("route") {
                        return format!("/route/{}", field_name);
                    } else if line.contains("dns") {
                        return format!("/dns/{}", field_name);
                    } else if line.contains("when") {
                        return format!("/route/rules/when/{}", field_name);
                    } else {
                        return format!("/{}", field_name);
                    }
                }
            }
        }

        // Look for patterns indicating missing required fields
        if line.contains("missing field") {
            if let Some(start) = line.find('`') {
                if let Some(end) = line[start + 1..].find('`') {
                    let field_name = &line[start + 1..start + 1 + end];
                    return format!("/{}", field_name);
                }
            }
        }

        // Look for type mismatch errors
        if line.contains("invalid type") {
            // Try to extract field context from error message
            if line.contains("expected") {
                return "/".to_string(); // Generic pointer for type errors
            }
        }
    }

    // Default to root pointer if we can't extract specific location
    "/".to_string()
}

/// Classify schema error and provide appropriate issue code and hint
fn classify_schema_error(error: &serde_json::Error) -> (IssueCode, Option<String>) {
    let error_str = error.to_string();

    if error_str.contains("unknown field") {
        (
            IssueCode::UnknownField,
            Some("Remove unknown field or check spelling".into()),
        )
    } else if error_str.contains("invalid type") || error_str.contains("expected") {
        let hint = if error_str.contains("expected string") {
            Some("Expected string value, got different type".into())
        } else if error_str.contains("expected number") {
            Some("Expected numeric value, got different type".into())
        } else if error_str.contains("expected boolean") {
            Some("Expected true/false, got different type".into())
        } else if error_str.contains("expected array") {
            Some("Expected list/array, got different type".into())
        } else if error_str.contains("expected object") {
            Some("Expected object/map, got different type".into())
        } else {
            Some("Data type mismatch - check expected type".into())
        };
        (IssueCode::TypeMismatch, hint)
    } else if error_str.contains("out of range")
        || error_str.contains("too large")
        || error_str.contains("too small")
        || error_str.contains("invalid value")
    {
        let hint = if error_str.contains("port") {
            Some("Port must be 1-65535".into())
        } else if error_str.contains("timeout") {
            Some("Timeout value out of acceptable range".into())
        } else {
            Some("Value outside acceptable range".into())
        };
        (IssueCode::OutOfRange, hint)
    } else if error_str.contains("missing field") {
        (IssueCode::MissingField, Some("Add required field".into()))
    } else {
        (
            IssueCode::SchemaViolation,
            Some("Schema validation error".into()),
        )
    }
}

/// Validate configuration against Schema v2 with strong typing
fn validate_schema_v2(config: &serde_json::Value, issues: &mut Vec<CheckIssue>) {
    #[cfg(feature = "schema-v2")]
    {
        match serde_json::from_value::<sb_core::config::schema_v2::ConfigV2>(config.clone()) {
            Ok(_) => {
                // Validation successful
            }
            Err(e) => {
                let ptr = extract_json_pointer_from_error(&e);
                let (code, hint) = classify_schema_error(&e);
                let issue = CheckIssue {
                    kind: IssueKind::Error,
                    code,
                    ptr,
                    msg: format!("schema v2 validation error: {}", e),
                    hint,
                    rule_id: None,
                    key: None,
                    members: None,
                    tos: None,
                    risk: None,
                };
                issues.push(issue);
            }
        }
    }
    #[cfg(not(feature = "schema-v2"))]
    {
        let issue = CheckIssue {
            kind: IssueKind::Warning,
            code: IssueCode::SchemaViolation,
            ptr: "/".into(),
            msg: "schema-v2 feature disabled at build".into(),
            hint: Some("rebuild with --features schema-v2 to enable".into()),
            rule_id: None,
            key: None,
            members: None,
            tos: None,
            risk: None,
        };
        issues.push(issue);
    }
}

/// Check feature availability and emit warnings for disabled features
fn check_feature_availability(args: &CheckArgs, issues: &mut Vec<CheckIssue>) {
    // Check schema-v2 feature availability
    if args.schema_v2_validate {
        #[cfg(not(feature = "schema-v2"))]
        {
            let issue = CheckIssue {
                kind: IssueKind::Warning,
                code: IssueCode::SchemaViolation,
                ptr: "/".into(),
                msg: "schema-v2-validate requested but feature disabled at build time".into(),
                hint: Some(
                    "Rebuild with --features schema-v2 to enable strong typing validation".into(),
                ),
                rule_id: None,
                key: None,
                members: None,
                tos: None,
                risk: None,
            };
            issues.push(issue);
        }
    }

    // Check negation suggestion feature availability
    if args.autofix_suggest_negation {
        #[cfg(not(feature = "check-bool"))]
        {
            let issue = CheckIssue {
                kind: IssueKind::Warning,
                code: IssueCode::UnreachableRule,
                ptr: "/".into(),
                msg: "autofix-suggest-negation requested but check-bool feature disabled at build time".into(),
                hint: Some("Rebuild with --features check-bool to enable negation suggestions".into()),
                rule_id: None,
                key: None,
                members: None,
                tos: None,
                risk: None,
            };
            issues.push(issue);
        }
    }

    // Check schema feature availability
    if args.schema {
        #[cfg(not(feature = "check-schema"))]
        {
            let issue = CheckIssue {
                kind: IssueKind::Warning,
                code: IssueCode::SchemaViolation,
                ptr: "/".into(),
                msg: "schema validation requested but check-schema feature disabled at build time"
                    .into(),
                hint: Some(
                    "Rebuild with --features check-schema to enable schema validation".into(),
                ),
                rule_id: None,
                key: None,
                members: None,
                tos: None,
                risk: None,
            };
            issues.push(issue);
        }
    }
}

fn hint_for(code: &IssueCode, ptr: &str) -> Option<String> {
    use IssueCode::*;
    match code {
        InvalidPort => Some("use integer 1..65535".into()),
        InvalidEnum => Some("pick from documented set".into()),
        MissingField => Some("add the required field".into()),
        MutualExclusive => Some("remove one of them".into()),
        RefMissing => Some("fix path or provide the file".into()),
        RefTooLarge => Some("increase --max-ref-size or reduce file".into()),
        CrossRefMissing => {
            if ptr.ends_with("/to") {
                Some("ensure pool exists in outbounds[].name".into())
            } else {
                None
            }
        }
        UnknownField => Some("remove unknown key or upgrade config if supported".into()),
        TypeMismatch => Some("check expected data type in documentation".into()),
        OutOfRange => Some("ensure value is within acceptable limits".into()),
        DuplicateName => Some("adjust to unique name".into()),
        PortConflict => Some("modify port or listen address".into()),
        BadCIDR => Some("use a.b.c.d/len or ipv6/len format".into()),
        BadDomain => Some("use exact, suffix, or '*.example.com' format".into()),
        ApiVersionMissing => Some("set to 'singbox/v1'".into()),
        KindMissing => Some("set to 'Config'".into()),
        ApiVersionUnknown => Some("supported: singbox/v1".into()),
        UnreachableRule => Some("narrow the earlier rule or reorder".into()),
        ShadowedBy => Some("move this rule earlier or restrict domain/cidr".into()),
        _ => None,
    }
}

fn is_port(v: &Value) -> bool {
    v.as_u64()
        .map(|p| (1..=65535).contains(&(p as u16 as u64)))
        .unwrap_or(false)
}

fn expect_str(v: &Value) -> bool {
    v.as_str().is_some()
}
fn expect_arr(v: &Value) -> bool {
    v.as_array().is_some()
}
fn val_at<'a>(v: &'a Value, ptr: &str) -> Option<&'a Value> {
    v.pointer(ptr)
}

fn starts_with_any(ptr: &str, prefixes: &[String]) -> bool {
    prefixes
        .iter()
        .any(|p| ptr == p || ptr.starts_with(&format!("{}/", p)))
}

fn collect_unknown_fields(
    root: &Value,
    strict: bool,
    allow: &[String],
    issues: &mut Vec<CheckIssue>,
) {
    // Basic check: for main objects/array items use fixed known-keys; rest left to Schema
    // Top level
    if let Some(obj) = root.as_object() {
        for k in obj.keys() {
            if !matches!(
                k.as_str(),
                "inbounds"
                    | "outbounds"
                    | "route"
                    | "dns"
                    | "rules_text"
                    | "rules_json"
                    | "apiVersion"
                    | "kind"
            ) {
                let ptr = format!("/{}", k);
                if !starts_with_any(&ptr, allow) && strict {
                    push_err(
                        issues,
                        IssueCode::UnknownField,
                        ptr,
                        "unknown top-level field",
                        None,
                    );
                } else if !starts_with_any(&ptr, allow) {
                    push_warn(
                        issues,
                        IssueCode::UnknownField,
                        ptr,
                        "unknown top-level field",
                        None,
                    );
                }
            }
        }
    }
}

fn check_names_and_ports(root: &Value, issues: &mut Vec<CheckIssue>) {
    use std::collections::{HashMap, HashSet};
    // outbound name duplication
    let mut seen: HashMap<String, usize> = HashMap::new();
    if let Some(arr) = root.get("outbounds").and_then(|x| x.as_array()) {
        for (i, ob) in arr.iter().enumerate() {
            if let Some(n) = ob.get("name").and_then(|x| x.as_str()) {
                if let Some(prev) = seen.insert(n.to_string(), i) {
                    push_err(
                        issues,
                        IssueCode::DuplicateName,
                        format!("/outbounds/{}", i),
                        format!(
                            "duplicate outbound.name '{}', previously at index {}",
                            n, prev
                        ),
                        None,
                    );
                }
            }
        }
    }
    // inbound port conflicts (listen,port same = conflict)
    let mut binds: HashSet<(String, u64)> = HashSet::new();
    if let Some(arr) = root.get("inbounds").and_then(|x| x.as_array()) {
        for (i, ib) in arr.iter().enumerate() {
            let listen = ib
                .get("listen")
                .and_then(|x| x.as_str())
                .unwrap_or("0.0.0.0")
                .to_string();
            let port = ib.get("port").and_then(|x| x.as_u64()).unwrap_or(0);
            if port != 0 {
                let key = (listen.clone(), port);
                if !binds.insert(key.clone()) {
                    push_err(
                        issues,
                        IssueCode::PortConflict,
                        format!("/inbounds/{}", i),
                        format!("port conflict on {}:{}", key.0, key.1),
                        None,
                    );
                }
            }
        }
    }
}

fn is_valid_cidr(s: &str) -> bool {
    // Simplest but safe: validate using built-in parsing approximation
    // Only accept a.b.c.d/len or xxxx:.../len forms
    let parts: Vec<&str> = s.split('/').collect();
    if parts.len() != 2 {
        return false;
    }
    let len_ok = parts[1].parse::<u8>().is_ok();
    let ip = parts[0];
    let v4 = ip.parse::<std::net::Ipv4Addr>().is_ok();
    let v6 = ip.parse::<std::net::Ipv6Addr>().is_ok();
    len_ok && (v4 || v6)
}

fn is_valid_domain(s: &str) -> bool {
    // Allow leading *.
    let s = s.strip_prefix("*.").unwrap_or(s);
    // Simplified: each segment 1..63, overall <=253, only alphanumeric and hyphen, no leading/trailing -
    if s.len() > 253 || s.is_empty() {
        return false;
    }
    for seg in s.split('.') {
        if seg.is_empty() || seg.len() > 63 {
            return false;
        }
        let bytes = seg.as_bytes();
        if bytes[0] == b'-' || bytes[bytes.len() - 1] == b'-' {
            return false;
        }
        if !seg.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {
            return false;
        }
    }
    true
}

fn check_rule_semantics(root: &Value, issues: &mut Vec<CheckIssue>) {
    if let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) {
        for (i, r) in rules.iter().enumerate() {
            let base = format!("/route/rules/{}", i);
            if let Some(when) = r.get("when").and_then(|x| x.as_object()) {
                if let Some(domains) = when.get("domain").and_then(|x| x.as_array()) {
                    for (j, d) in domains.iter().enumerate() {
                        if let Some(s) = d.as_str() {
                            if !is_valid_domain(s) {
                                push_err(
                                    issues,
                                    IssueCode::BadDomain,
                                    format!("{}/when/domain/{}", base, j),
                                    format!("invalid domain pattern '{}'", s),
                                    Some("use exact, suffix, or '*.example.com'"),
                                );
                            }
                        }
                    }
                }
                if let Some(cidrs) = when.get("cidr").and_then(|x| x.as_array()) {
                    for (j, c) in cidrs.iter().enumerate() {
                        if let Some(s) = c.as_str() {
                            if !is_valid_cidr(s) {
                                push_err(
                                    issues,
                                    IssueCode::BadCIDR,
                                    format!("{}/when/cidr/{}", base, j),
                                    format!("invalid CIDR '{}'", s),
                                    Some("use a.b.c.d/len or ipv6/len"),
                                );
                            }
                        }
                    }
                }
            }
        }
    }
}

fn check_dns(root: &Value, issues: &mut Vec<CheckIssue>) {
    if let Some(dns) = val_at(root, "/dns") {
        if let Some(mode) = dns.get("mode") {
            let ok = mode
                .as_str()
                .map(|s| matches!(s, "system" | "udp" | "dot" | "doh"))
                .unwrap_or(false);
            if !ok {
                push_err(
                    issues,
                    IssueCode::InvalidEnum,
                    "/dns/mode",
                    "invalid dns.mode",
                    Some("expected one of: system|udp|dot|doh"),
                );
            }
        } else {
            push_warn(
                issues,
                IssueCode::MissingField,
                "/dns",
                "missing dns.mode",
                Some("default behaves as system in most setups"),
            );
        }
        if let Some(bks) = dns.get("backends") {
            if let Some(arr) = bks.as_array() {
                for (i, b) in arr.iter().enumerate() {
                    let base = format!("/dns/backends/{}", i);
                    let t = b.get("type").and_then(|x| x.as_str()).unwrap_or("");
                    match t {
                        "udp" => {
                            if !b.get("server").map(expect_str).unwrap_or(false) {
                                push_err(
                                    issues,
                                    IssueCode::MissingField,
                                    format!("{}/server", base),
                                    "udp backend requires 'server'",
                                    None,
                                );
                            }
                        }
                        "dot" => {
                            if !b.get("server").map(expect_str).unwrap_or(false) {
                                push_err(
                                    issues,
                                    IssueCode::MissingField,
                                    format!("{}/server", base),
                                    "dot backend requires 'server'",
                                    None,
                                );
                            }
                            if !b.get("sni").map(expect_str).unwrap_or(false) {
                                push_err(
                                    issues,
                                    IssueCode::MissingField,
                                    format!("{}/sni", base),
                                    "dot backend requires 'sni'",
                                    None,
                                );
                            }
                        }
                        "doh" => {
                            if !b.get("url").map(expect_str).unwrap_or(false) {
                                push_err(
                                    issues,
                                    IssueCode::MissingField,
                                    format!("{}/url", base),
                                    "doh backend requires 'url'",
                                    None,
                                );
                            }
                        }
                        "system" | "" => { /* ok / or inherited */ }
                        other => {
                            push_err(
                                issues,
                                IssueCode::InvalidEnum,
                                format!("{}/type", base),
                                format!("unknown backend type '{}'", other),
                                Some("udp|dot|doh|system"),
                            );
                        }
                    }
                }
            } else {
                push_err(
                    issues,
                    IssueCode::InvalidType,
                    "/dns/backends",
                    "dns.backends must be an array",
                    None,
                );
            }
        }
    }
}

fn check_inbounds(root: &Value, issues: &mut Vec<CheckIssue>) {
    let Some(inb) = root.get("inbounds") else {
        push_err(
            issues,
            IssueCode::MissingField,
            "",
            "missing 'inbounds'",
            Some("at least one inbound is required"),
        );
        return;
    };
    if !inb.is_array() {
        push_err(
            issues,
            IssueCode::InvalidType,
            "/inbounds",
            "'inbounds' must be an array",
            None,
        );
        return;
    }
    for (i, ib) in inb.as_array().unwrap().iter().enumerate() {
        let base = format!("/inbounds/{}", i);
        let Some(t) = ib.get("type") else {
            push_err(
                issues,
                IssueCode::MissingField,
                format!("{}/type", base),
                "missing 'type'",
                Some("http|socks|tun|redir..."),
            );
            continue;
        };
        let t = t.as_str().unwrap_or("");
        match t {
            "http" | "socks" => {
                if !ib.get("listen").map(expect_str).unwrap_or(false) {
                    push_err(
                        issues,
                        IssueCode::MissingField,
                        format!("{}/listen", base),
                        "missing 'listen'",
                        None,
                    );
                }
                if !ib.get("port").map(is_port).unwrap_or(false) {
                    push_err(
                        issues,
                        IssueCode::InvalidPort,
                        format!("{}/port", base),
                        "invalid 'port'",
                        Some("1..65535"),
                    );
                }
            }
            _ => { /* 留给后续扩展，但至少有 type */ }
        }
    }
}

fn check_outbounds(root: &Value, issues: &mut Vec<CheckIssue>) {
    let Some(outb) = root.get("outbounds") else {
        push_err(
            issues,
            IssueCode::MissingField,
            "",
            "missing 'outbounds'",
            Some("at least one outbound is required"),
        );
        return;
    };
    if !outb.is_array() {
        push_err(
            issues,
            IssueCode::InvalidType,
            "/outbounds",
            "'outbounds' must be an array",
            None,
        );
        return;
    }
    for (i, ob) in outb.as_array().unwrap().iter().enumerate() {
        let base = format!("/outbounds/{}", i);
        let Some(t) = ob.get("type") else {
            push_err(
                issues,
                IssueCode::MissingField,
                format!("{}/type", base),
                "missing 'type'",
                Some("direct|socks|http|proxy..."),
            );
            continue;
        };
        match t.as_str().unwrap_or("") {
            "direct" => {}
            "socks" | "http" => {
                if !ob.get("server").map(expect_str).unwrap_or(false) {
                    push_err(
                        issues,
                        IssueCode::MissingField,
                        format!("{}/server", base),
                        "missing 'server'",
                        None,
                    );
                }
                if !ob.get("port").map(is_port).unwrap_or(false) {
                    push_err(
                        issues,
                        IssueCode::InvalidPort,
                        format!("{}/port", base),
                        "invalid 'port'",
                        Some("1..65535"),
                    );
                }
            }
            _ => { /* 允许未知类型，后续细化 */ }
        }
    }
}

fn check_route(root: &Value, issues: &mut Vec<CheckIssue>) {
    if let Some(route) = root.get("route") {
        if let Some(rules) = route.get("rules") {
            if !rules.is_array() {
                push_err(
                    issues,
                    IssueCode::InvalidType,
                    "/route/rules",
                    "'rules' must be an array",
                    None,
                );
                return;
            }
            for (i, r) in rules.as_array().unwrap().iter().enumerate() {
                let base = format!("/route/rules/{}", i);
                if let Some(when) = r.get("when") {
                    if let Some(proto) = when.get("proto") {
                        if !expect_arr(proto) {
                            push_err(
                                issues,
                                IssueCode::InvalidType,
                                format!("{}/when/proto", base),
                                "'proto' must be array",
                                Some(r#"["tcp","udp"]"#),
                            );
                        } else {
                            let bad = proto
                                .as_array()
                                .unwrap()
                                .iter()
                                .filter_map(|v| v.as_str())
                                .any(|s| s != "tcp" && s != "udp");
                            if bad {
                                push_err(
                                    issues,
                                    IssueCode::InvalidEnum,
                                    format!("{}/when/proto", base),
                                    "proto only supports tcp|udp",
                                    None,
                                );
                            }
                        }
                    }
                }
                if r.get("to").and_then(|x| x.as_str()).is_none() {
                    push_err(
                        issues,
                        IssueCode::MissingField,
                        format!("{}/to", base),
                        "missing 'to'",
                        Some(r#""direct" or "proxy:<name>""#),
                    );
                }
            }
        }
    }
}

fn check_rules_mutex(root: &Value, issues: &mut Vec<CheckIssue>) {
    let has_text = root.get("rules_text").is_some();
    let has_json = root.get("rules_json").is_some();
    if has_text && has_json {
        push_err(
            issues,
            IssueCode::MutualExclusive,
            "/",
            "rules_text and rules_json are mutually exclusive",
            Some("remove one of them"),
        );
    }
}

fn schema_v1() -> Value {
    // 手写 v1 JSON Schema（最小必需字段；可逐步演进），Draft 7 兼容
    json!({
      "$schema": "http://json-schema.org/draft-07/schema#",
      "type": "object",
      "properties": {
        "inbounds": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": { "type": "string", "enum": ["http","socks","tun","redir","mixed"] },
              "listen": { "type": "string" },
              "port": { "type": "integer", "minimum": 1, "maximum": 65535 }
            },
            "required": ["type"]
          },
          "minItems": 1
        },
        "outbounds": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "type": { "type": "string", "enum": ["direct","socks","http","proxy"] },
              "server": { "type": "string" },
              "port": { "type": "integer", "minimum": 1, "maximum": 65535 }
            },
            "required": ["type"]
          },
          "minItems": 1
        },
        "route": {
          "type": "object",
          "properties": {
            "rules": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": { "type": "string" },
                  "when": {
                    "type":"object",
                    "properties": {
                      "proto": { "type": "array", "items": { "type":"string", "enum": ["tcp","udp"] } }
                    }
                  },
                  "to": { "type": "string" }
                },
                "required": ["to"]
              }
            }
          }
        },
        "dns": {
          "type": "object",
          "properties": {
            "mode": { "type": "string", "enum": ["system","udp","dot","doh"] },
            "backends": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": { "type": "string", "enum": ["system","udp","dot","doh"] },
                  "server": { "type": "string" },
                  "sni": { "type": "string" },
                  "url": { "type": "string" }
                }
              }
            }
          }
        }
      },
      "required": ["inbounds","outbounds"]
    })
}

// v1 schema 基础上，按 deny_unknown 选择 additionalProperties
#[allow(dead_code)]
fn schema_v1_with_strict(strict: bool) -> Value {
    let mut s = schema_v1();
    if strict {
        // 顶层
        if let Some(obj) = s.as_object_mut() {
            obj.insert("additionalProperties".into(), Value::Bool(false));
        }
        // 针对 inbounds/outbounds/route/dns 内层对象，同样设置
        // 简化处理：用路径指针定位常见层级并覆盖
        let ptrs = [
            "/properties/inbounds/items",
            "/properties/outbounds/items",
            "/properties/route",
            "/properties/route/properties/rules/items",
            "/properties/dns",
            "/properties/dns/properties/backends/items",
        ];
        for p in ptrs {
            if let Some(v) = s.pointer_mut(p) {
                if let Some(obj) = v.as_object_mut() {
                    obj.insert("additionalProperties".into(), Value::Bool(false));
                }
            }
        }
    }
    s
}

fn resolve_with_root(path: &str, root: &Option<PathBuf>) -> PathBuf {
    let pb = PathBuf::from(path);
    if pb.is_absolute() || root.is_none() {
        pb
    } else {
        root.as_ref().unwrap().join(pb)
    }
}

fn check_refs(root: &Value, args: &CheckArgs, issues: &mut Vec<CheckIssue>) {
    // 约定探测：rules_text / rules_json（文件路径字符串）；以及 "*file"/"*path" 后缀字段
    let mut candidates: Vec<(String, String)> = Vec::new();
    if let Some(v) = root.get("rules_text").and_then(|x| x.as_str()) {
        candidates.push(("/rules_text".into(), v.into()));
    }
    if let Some(v) = root.get("rules_json").and_then(|x| x.as_str()) {
        candidates.push(("/rules_json".into(), v.into()));
    }
    // 广度扫描：所有 string 字段名以 file/path 结尾的
    fn scan(ptr: String, val: &Value, out: &mut Vec<(String, String)>) {
        match val {
            Value::Object(map) => {
                for (k, v) in map {
                    let p = format!("{}/{}", ptr, k);
                    let kl = k.to_lowercase();
                    if (kl.ends_with("file") || kl.ends_with("path")) && v.as_str().is_some() {
                        out.push((p.clone(), v.as_str().unwrap().to_string()));
                    }
                    scan(p, v, out);
                }
            }
            Value::Array(arr) => {
                for (i, v) in arr.iter().enumerate() {
                    scan(format!("{}/{}", ptr, i), v, out);
                }
            }
            _ => {}
        }
    }
    scan("".into(), root, &mut candidates);
    // 校验：存在性、可读性、大小
    for (ptr, path) in candidates {
        let pb = resolve_with_root(&path, &args.rules_dir);
        if !pb.exists() {
            push_err(
                issues,
                IssueCode::RefMissing,
                ptr.clone(),
                format!("referenced file not found: {}", path),
                None,
            );
            continue;
        }
        match std::fs::read(&pb) {
            Ok(buf) => {
                if buf.len() > args.max_ref_size {
                    push_err(
                        issues,
                        IssueCode::RefTooLarge,
                        ptr.clone(),
                        format!("referenced file too large: {} bytes", buf.len()),
                        Some(&format!("max {}", args.max_ref_size)),
                    );
                }
                // 尝试 UTF-8
                if std::str::from_utf8(&buf).is_err() {
                    push_warn(
                        issues,
                        IssueCode::RefUnreadable,
                        ptr.clone(),
                        "referenced file not valid UTF-8",
                        None,
                    );
                }
            }
            Err(_) => {
                push_err(
                    issues,
                    IssueCode::RefUnreadable,
                    ptr.clone(),
                    format!("cannot read file: {}", path),
                    None,
                );
            }
        }
    }
}

fn check_cross_refs(root: &Value, issues: &mut Vec<CheckIssue>) {
    // 收集 outbounds 可引用名字
    let mut names = std::collections::HashSet::<String>::new();
    if let Some(obs) = root.get("outbounds").and_then(|x| x.as_array()) {
        for ob in obs {
            if let Some(n) = ob.get("name").and_then(|x| x.as_str()) {
                names.insert(n.to_string());
            }
        }
    }
    // 扫描 route.rules[].to
    if let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) {
        for (i, r) in rules.iter().enumerate() {
            if let Some(to) = r.get("to").and_then(|x| x.as_str()) {
                if let Some(pool) = to.strip_prefix("proxy:") {
                    if !names.contains(pool) {
                        push_err(
                            issues,
                            IssueCode::CrossRefMissing,
                            format!("/route/rules/{}/to", i),
                            format!("proxy pool '{}' not found in outbounds[].name", pool),
                            None,
                        );
                    }
                }
            }
        }
    }
}

// === 覆盖性分析（半形式化）：基于域名/CIDR包含关系的精确判定 ===

#[derive(Default, Clone)]
struct DomPat {
    exact: Vec<String>,  // "a.b.c"
    suffix: Vec<String>, // "example.com" for "*.example.com"
}

fn norm_domains(a: &serde_json::Value) -> DomPat {
    let mut d = DomPat::default();
    if let Some(arr) = a.as_array() {
        for v in arr {
            if let Some(s) = v.as_str() {
                if let Some(rest) = s.strip_prefix("*.") {
                    d.suffix.push(rest.to_ascii_lowercase());
                } else {
                    d.exact.push(s.to_ascii_lowercase());
                }
            }
        }
    }
    d
}

#[cfg(feature = "check-net")]
fn norm_cidrs(a: &serde_json::Value) -> Vec<IpNet> {
    let mut out = Vec::new();
    if let Some(arr) = a.as_array() {
        for v in arr {
            if let Some(s) = v.as_str() {
                if let Ok(n) = s.parse::<IpNet>() {
                    out.push(n);
                }
            }
        }
    }
    out
}

fn domain_contains(a: &DomPat, b: &DomPat) -> bool {
    // a 是否覆盖 b：任一 b.exact 被 a.exact 命中或被 a.suffix 覆盖；b.suffix 被 a.suffix 的更短或相等后缀覆盖
    for ex in &b.exact {
        if a.exact.iter().any(|x| x == ex) {
            continue;
        }
        if !a
            .suffix
            .iter()
            .any(|suf| ex.ends_with(&format!(".{}", suf)) || ex == suf)
        {
            return false;
        }
    }
    for suf_b in &b.suffix {
        if a.suffix
            .iter()
            .any(|suf_a| suf_b == suf_a || suf_b.ends_with(&format!(".{}", suf_a)))
        {
            continue;
        }
        return false;
    }
    true
}

#[cfg(feature = "check-net")]
fn cidr_contains(a: &[IpNet], b: &[IpNet]) -> bool {
    // a 是否覆盖 b：每个 b 都被 a 中某个网络包含
    fn one_contains(a: &IpNet, b: &IpNet) -> bool {
        match (a, b) {
            (IpNet::V4(aa), IpNet::V4(bb)) => {
                aa.contains(&bb.network()) && aa.prefix_len() <= bb.prefix_len()
            }
            (IpNet::V6(aa), IpNet::V6(bb)) => {
                aa.contains(&bb.network()) && aa.prefix_len() <= bb.prefix_len()
            }
            _ => false,
        }
    }
    'outer: for bn in b {
        for an in a {
            if one_contains(an, bn) {
                continue 'outer;
            }
        }
        return false;
    }
    true
}

#[derive(Default, Clone)]
struct WhenShape {
    any: bool,
    proto_all: bool,
    proto_set: std::collections::BTreeSet<String>,
    dom: DomPat,
    not_dom: DomPat,
    #[cfg(feature = "check-net")]
    cidr: Vec<IpNet>,
    #[cfg(feature = "check-net")]
    not_cidr: Vec<IpNet>,
    has_domain: bool,
    has_cidr: bool,
    not_proto: bool,
}

fn shape_of_when(v: &serde_json::Value) -> WhenShape {
    let mut s = WhenShape::default();
    if !v.is_object() || v.as_object().unwrap().is_empty() {
        s.any = true;
        return s;
    }
    if let Some(p) = v.get("proto").and_then(|x| x.as_array()) {
        for e in p {
            if let Some(ps) = e.as_str() {
                s.proto_set.insert(ps.to_string());
            }
        }
    }
    s.proto_all = s.proto_set.contains("tcp") && s.proto_set.contains("udp");

    // Check for proto negation
    if let Some(not_proto) = v.get("not_proto").and_then(|x| x.as_bool()) {
        s.not_proto = not_proto;
    }

    if let Some(dv) = v.get("domain") {
        s.dom = norm_domains(dv);
        s.has_domain = !s.dom.exact.is_empty() || !s.dom.suffix.is_empty();
    }

    // Check for domain negation
    if let Some(not_dv) = v.get("not_domain") {
        s.not_dom = norm_domains(not_dv);
    }

    if let Some(cv) = v.get("cidr") {
        s.has_cidr = cv.as_array().map(|a| !a.is_empty()).unwrap_or(false);
        #[cfg(feature = "check-net")]
        {
            s.cidr = norm_cidrs(cv);
        }
    }

    // Check for CIDR negation
    if let Some(not_cv) = v.get("not_cidr") {
        #[cfg(feature = "check-net")]
        {
            s.not_cidr = norm_cidrs(not_cv);
        }
    }

    s
}

fn proto_covers(a: &WhenShape, b: &WhenShape) -> bool {
    if a.proto_all {
        return true;
    }
    b.proto_set.is_subset(&a.proto_set)
}

fn domains_covers(a: &WhenShape, b: &WhenShape) -> bool {
    if !a.has_domain && b.has_domain {
        return false;
    }
    if !b.has_domain {
        return true;
    }
    domain_contains(&a.dom, &b.dom)
}

#[cfg(feature = "check-net")]
fn cidrs_covers(a: &WhenShape, b: &WhenShape) -> bool {
    if !a.has_cidr && b.has_cidr {
        return false;
    }
    if !b.has_cidr {
        return true;
    }
    cidr_contains(&a.cidr, &b.cidr)
}

fn is_broader(a: &WhenShape, b: &WhenShape) -> bool {
    if a.any {
        return true;
    }
    if !proto_covers(a, b) {
        return false;
    }
    if !domains_covers(a, b) {
        return false;
    }
    #[cfg(feature = "check-net")]
    {
        if !cidrs_covers(a, b) {
            return false;
        }
    }
    true
}

fn rule_key_of(w: &WhenShape) -> RuleKey {
    let mut proto_w = 0;
    if w.proto_set.contains("tcp") {
        proto_w |= 1;
    }
    if w.proto_set.contains("udp") {
        proto_w |= 2;
    }
    RuleKey {
        proto_w,
        dom_cnt: (w.dom.exact.len() + w.dom.suffix.len()),
        cidr_cnt: {
            #[cfg(feature = "check-net")]
            {
                w.cidr.len()
            }
            #[cfg(not(feature = "check-net"))]
            {
                if w.has_cidr {
                    1
                } else {
                    0
                }
            }
        },
    }
}

fn minimize_rules(root: &serde_json::Value) -> serde_json::Value {
    let mut v = canonicalize(root);
    let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) else {
        return v;
    };
    // Pre-compute shapes
    let mut keeps = vec![true; rules.len()];
    let mut shapes = Vec::with_capacity(rules.len());
    for r in rules {
        shapes.push(shape_of_when(
            r.get("when").unwrap_or(&serde_json::json!({})),
        ));
    }
    // From front to back, mark those fully covered by earlier ones for deletion
    for i in 0..rules.len() {
        if !keeps[i] {
            continue;
        }
        for j in (i + 1)..rules.len() {
            if !keeps[j] {
                continue;
            }
            if is_broader(&shapes[i], &shapes[j]) {
                keeps[j] = false;
            }
        }
    }
    let mut new_rules = Vec::new();
    for (i, r) in rules.iter().enumerate() {
        if keeps[i] {
            new_rules.push(canonicalize(r));
        }
    }
    if let Some(route) = v.get_mut("route") {
        if let Some(obj) = route.as_object_mut() {
            obj.insert("rules".into(), serde_json::Value::Array(new_rules));
        }
    }
    v
}

/// 扫描 route.rules[].when 是否包含任意 not_* 键（如 not_domain/not_cidr/not_proto 等）
fn has_negation(root: &serde_json::Value) -> bool {
    let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) else {
        return false;
    };
    for r in rules {
        if let Some(w) = r.get("when").and_then(|x| x.as_object()) {
            if w.keys().any(|k| k.starts_with("not_")) {
                return true;
            }
        }
    }
    false
}

fn apply_plan_to(root: &serde_json::Value, plan: &[serde_json::Value]) -> serde_json::Value {
    // Only support move/replace, strictly memory operations only
    let mut v = root.clone();
    for op in plan {
        let typ = op.get("op").and_then(|x| x.as_str()).unwrap_or("");
        match typ {
            "move" => {
                let from = op.get("from").and_then(|x| x.as_str()).unwrap_or("");
                let path = op.get("path").and_then(|x| x.as_str()).unwrap_or("");
                v = json_patch_move(&v, from, path);
            }
            "replace" => {
                let path = op.get("path").and_then(|x| x.as_str()).unwrap_or("");
                let val = op.get("value").cloned().unwrap_or(serde_json::Value::Null);
                v = json_patch_replace(&v, path, val);
            }
            _ => {}
        }
    }
    canonicalize(&v)
}

fn json_patch_move(root: &serde_json::Value, from: &str, path: &str) -> serde_json::Value {
    // Minimal implementation: only handle /route/rules/<idx> simple paths
    let mut v = root.clone();
    let pop_idx = |p: &str| -> Option<usize> { p.rsplit('/').next()?.parse::<usize>().ok() };
    if let (Some(fi), Some(ti)) = (pop_idx(from), pop_idx(path)) {
        if let Some(rules) = v
            .pointer("/route/rules")
            .and_then(|x| x.as_array())
            .cloned()
        {
            let mut arr = rules;
            if fi < arr.len() && ti < arr.len() {
                let item = arr.remove(fi);
                arr.insert(ti, item);
                if let Some(route) = v.get_mut("route") {
                    if let Some(obj) = route.as_object_mut() {
                        obj.insert("rules".into(), serde_json::Value::Array(arr));
                    }
                }
            }
        }
    }
    v
}
fn json_patch_replace(
    root: &serde_json::Value,
    path: &str,
    val: serde_json::Value,
) -> serde_json::Value {
    // Only support /route/rules/<idx>/when/<field> or /dns/<field> shallow paths (sufficient and controllable)
    // Simplest but clear: clone + pointer rebuild
    let mut v = root.clone();
    let seg: Vec<&str> = path.trim_start_matches('/').split('/').collect();
    if seg.len() >= 3 && seg[0] == "route" && seg[1] == "rules" {
        if let Ok(idx) = seg[2].parse::<usize>() {
            if let Some(mut rules) = v
                .pointer("/route/rules")
                .and_then(|x| x.as_array())
                .cloned()
            {
                if idx < rules.len() {
                    if seg.len() == 3 {
                        rules[idx] = val;
                    } else {
                        // /route/rules/idx/when/...
                        let mut r = rules[idx].clone();
                        if let Some(cur) = r.as_object_mut() {
                            if seg[3] == "when" {
                                cur.insert("when".into(), val);
                                rules[idx] = serde_json::Value::Object(cur.clone());
                            }
                        }
                    }
                    if let Some(route) = v.get_mut("route") {
                        if let Some(obj) = route.as_object_mut() {
                            obj.insert("rules".into(), serde_json::Value::Array(rules));
                        }
                    }
                }
            }
        }
    }
    v
}

fn build_autofix_plan(root: &Value) -> Vec<RuleFixOp> {
    // 规则重排：更"窄"的优先（有 domain/cidr 的在前，同等再按 proto 更具体在前）
    let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) else {
        return vec![];
    };
    // 建索引
    let mut items: Vec<(usize, WhenShape, RuleKey)> = Vec::new();
    for (i, r) in rules.iter().enumerate() {
        let when = r
            .get("when")
            .cloned()
            .unwrap_or(Value::Object(serde_json::Map::new()));
        let ws = shape_of_when(&when);
        let k = rule_key_of(&ws);
        items.push((i, ws, k));
    }
    // 计算目标顺序
    let mut order: Vec<usize> = (0..items.len()).collect();
    order.sort_by(|&a, &b| {
        let ka = &items[a].2;
        let kb = &items[b].2;
        // dom/cidr 多者更窄 → 靠前
        ka.dom_cnt
            .cmp(&kb.dom_cnt)
            .reverse()
            .then(ka.cidr_cnt.cmp(&kb.cidr_cnt).reverse())
            .then(ka.proto_w.cmp(&kb.proto_w).reverse())
            .then(a.cmp(&b)) // 稳定
    });
    // 生成 move ops（把元素移动到目标下标）
    let mut ops: Vec<RuleFixOp> = Vec::new();
    if order.iter().enumerate().any(|(dst, &src)| dst != src) {
        // 用简单 moves 表达；真正应用由外部工具做
        for (dst, &src) in order.iter().enumerate() {
            if dst != src {
                ops.push(RuleFixOp {
                    op: "move".into(),
                    from: Some(format!("/route/rules/{}", src)),
                    path: format!("/route/rules/{}", dst),
                    value: None,
                    note: Some("reorder by specificity (narrow-first)".into()),
                });
            }
        }
    }
    // 可选：将非法 domain/cidr 的建议"收紧"为 hint（不直接替换，防止误修）
    ops
}

#[cfg(feature = "check-bool")]
fn suggest_negation_fixes(root: &Value) -> Vec<NegationSuggestion> {
    let mut suggestions = Vec::new();

    let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) else {
        return suggestions;
    };

    for (i, rule) in rules.iter().enumerate() {
        let when = rule.get("when").cloned().unwrap_or(json!({}));
        let shape = shape_of_when(&when);

        // Check if rule has negation fields
        let has_not_domain = !shape.not_dom.exact.is_empty() || !shape.not_dom.suffix.is_empty();
        #[cfg(feature = "check-net")]
        let has_not_cidr = !shape.not_cidr.is_empty();
        #[cfg(not(feature = "check-net"))]
        let has_not_cidr = false;
        let has_not_proto = shape.not_proto;

        if !has_not_domain && !has_not_cidr && !has_not_proto {
            continue; // No negation to suggest fixes for
        }

        // Check if this rule results in empty set after negation
        #[cfg(feature = "check-bool")]
        let (is_empty, reason) = {
            let bool_when = bool_when::to_bool_when(&shape);
            bool_when::is_empty_after_negation(&bool_when)
        };
        #[cfg(not(feature = "check-bool"))]
        let (is_empty, reason) = (false, "");

        if is_empty {
            // Generate suggestion for conflicting negation rules
            let suggestion_type = match reason {
                "domain_neg" => "split_domain_allow_deny",
                "cidr_neg" => "split_cidr_allow_deny",
                "proto_neg" => "remove_proto_negation",
                _ => "split_allow_deny",
            };

            let description = match reason {
                "domain_neg" => format!("Rule {} has domain negation that results in empty match. Consider splitting into explicit allow/deny rules.", i),
                "cidr_neg" => format!("Rule {} has CIDR negation that results in empty match. Consider splitting into explicit allow/deny rules.", i),
                "proto_neg" => format!("Rule {} has protocol negation that conflicts with specified protocols. Consider removing not_proto or proto constraint.", i),
                _ => format!("Rule {} has negation that results in empty match. Consider splitting into explicit allow/deny rules.", i)
            };

            let json_patch = generate_negation_split_patch(i, &when, reason);

            suggestions.push(NegationSuggestion {
                rule_index: i,
                suggestion_type: suggestion_type.to_string(),
                description,
                json_patch,
            });
        } else if has_not_domain || has_not_cidr {
            // Generate suggestion for non-conflicting but complex negation rules
            let description = format!("Rule {} uses negation that could be split into explicit allow/deny rules for better clarity.", i);
            let json_patch = generate_negation_split_patch(i, &when, "clarity");

            suggestions.push(NegationSuggestion {
                rule_index: i,
                suggestion_type: "split_allow_deny".to_string(),
                description,
                json_patch,
            });
        }
    }

    suggestions
}

fn generate_negation_split_patch(
    rule_index: usize,
    when: &Value,
    reason: &str,
) -> Vec<serde_json::Value> {
    let mut patches = Vec::new();
    let base_path = format!("/route/rules/{}", rule_index);

    match reason {
        "domain_neg" => {
            // Split domain negation into separate allow/deny rules
            if let Some(not_domain) = when.get("not_domain") {
                // Remove the original rule
                patches.push(json!({
                    "op": "remove",
                    "path": base_path
                }));

                // Create explicit deny rule for not_domain
                let mut deny_when = when.clone();
                if let Some(deny_when_obj) = deny_when.as_object_mut() {
                    deny_when_obj.remove("not_domain");
                    deny_when_obj.insert("domain".to_string(), not_domain.clone());
                }

                patches.push(json!({
                    "op": "add",
                    "path": format!("/route/rules/{}", rule_index),
                    "value": {
                        "when": deny_when,
                        "to": "block"
                    }
                }));

                // Create allow rule for original domain (if any)
                if let Some(domain) = when.get("domain") {
                    let mut allow_when = when.clone();
                    if let Some(allow_when_obj) = allow_when.as_object_mut() {
                        allow_when_obj.remove("not_domain");
                    }

                    patches.push(json!({
                        "op": "add",
                        "path": format!("/route/rules/{}", rule_index + 1),
                        "value": {
                            "when": allow_when,
                            "to": when.pointer("/../to").unwrap_or(&json!("direct"))
                        }
                    }));
                }
            }
        }
        "cidr_neg" => {
            // Split CIDR negation into separate allow/deny rules
            if let Some(not_cidr) = when.get("not_cidr") {
                // Remove the original rule
                patches.push(json!({
                    "op": "remove",
                    "path": base_path
                }));

                // Create explicit deny rule for not_cidr
                let mut deny_when = when.clone();
                if let Some(deny_when_obj) = deny_when.as_object_mut() {
                    deny_when_obj.remove("not_cidr");
                    deny_when_obj.insert("cidr".to_string(), not_cidr.clone());
                }

                patches.push(json!({
                    "op": "add",
                    "path": format!("/route/rules/{}", rule_index),
                    "value": {
                        "when": deny_when,
                        "to": "block"
                    }
                }));

                // Create allow rule for original cidr (if any)
                if let Some(cidr) = when.get("cidr") {
                    let mut allow_when = when.clone();
                    if let Some(allow_when_obj) = allow_when.as_object_mut() {
                        allow_when_obj.remove("not_cidr");
                    }

                    patches.push(json!({
                        "op": "add",
                        "path": format!("/route/rules/{}", rule_index + 1),
                        "value": {
                            "when": allow_when,
                            "to": when.pointer("/../to").unwrap_or(&json!("direct"))
                        }
                    }));
                }
            }
        }
        "proto_neg" => {
            // Remove conflicting proto negation
            patches.push(json!({
                "op": "remove",
                "path": format!("{}/when/not_proto", base_path)
            }));
        }
        _ => {
            // General case: suggest splitting complex negation
            let mut simplified_when = when.clone();
            if let Some(when_obj) = simplified_when.as_object_mut() {
                when_obj.remove("not_domain");
                when_obj.remove("not_cidr");
                when_obj.remove("not_proto");
            }

            patches.push(json!({
                "op": "replace",
                "path": format!("{}/when", base_path),
                "value": simplified_when
            }));
        }
    }

    patches
}

#[cfg(not(feature = "check-bool"))]
fn suggest_negation_fixes(_root: &Value) -> Vec<NegationSuggestion> {
    // Return empty suggestions when check-bool feature is not enabled
    Vec::new()
}

fn normalize_config(root: &Value) -> Value {
    // 仅做：对象键排序 + 规则按上面 order 排序；不尝试写入新字段
    let mut v = canonicalize(root);
    if let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) {
        let mut pairs: Vec<(usize, Value, RuleKey)> = Vec::new();
        for (i, r) in rules.iter().enumerate() {
            let when = r
                .get("when")
                .cloned()
                .unwrap_or(Value::Object(serde_json::Map::new()));
            let ws = shape_of_when(&when);
            let k = rule_key_of(&ws);
            pairs.push((i, canonicalize(r), k));
        }
        pairs.sort_by(|a, b| {
            a.2.dom_cnt
                .cmp(&b.2.dom_cnt)
                .reverse()
                .then(a.2.cidr_cnt.cmp(&b.2.cidr_cnt).reverse())
                .then(a.2.proto_w.cmp(&b.2.proto_w).reverse())
                .then(a.0.cmp(&b.0))
        });
        let mut new_rules = Vec::with_capacity(pairs.len());
        for (_, r, _) in pairs {
            new_rules.push(r);
        }
        if let Some(route) = v.get_mut("route") {
            if let Some(obj) = route.as_object_mut() {
                obj.insert("rules".into(), Value::Array(new_rules));
            }
        }
    }
    v
}

fn print_summary(root: &Value) {
    let inb = root
        .get("inbounds")
        .and_then(|x| x.as_array())
        .map(|a| a.len())
        .unwrap_or(0);
    let outb = root
        .get("outbounds")
        .and_then(|x| x.as_array())
        .map(|a| a.len())
        .unwrap_or(0);
    let rules = root
        .pointer("/route/rules")
        .and_then(|x| x.as_array())
        .map(|a| a.len())
        .unwrap_or(0);
    use std::collections::BTreeSet;
    let mut ports = BTreeSet::new();
    if let Some(arr) = root.get("inbounds").and_then(|x| x.as_array()) {
        for e in arr {
            if let Some(p) = e.get("port").and_then(|x| x.as_u64()) {
                ports.insert(p);
            }
        }
    }
    let mut pools = BTreeSet::new();
    if let Some(arr) = root.get("outbounds").and_then(|x| x.as_array()) {
        for e in arr {
            if let Some(n) = e.get("name").and_then(|x| x.as_str()) {
                pools.insert(n.to_string());
            }
        }
    }
    println!(
        "SUMMARY: inbounds={}, outbounds={}, rules={}, ports={:?}, pools={:?}",
        inb, outb, rules, ports, pools
    );
}

fn analyze_rule_coverage(root: &Value, issues: &mut Vec<CheckIssue>, with_rule_id: bool) {
    let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) else {
        return;
    };
    let mut acc: Vec<WhenShape> = Vec::new();
    for (i, r) in rules.iter().enumerate() {
        let when = r
            .get("when")
            .cloned()
            .unwrap_or(Value::Object(serde_json::Map::new()));
        let s = shape_of_when(&when);
        // 被前序完全覆盖 → Unreachable
        for (j, prev) in acc.iter().enumerate() {
            if is_broader(prev, &s) {
                let rid = if with_rule_id {
                    format!(" [{}]", rule_id_of(&r))
                } else {
                    "".into()
                };
                push_err(
                    issues,
                    IssueCode::UnreachableRule,
                    format!("/route/rules/{}{}", i, rid),
                    format!("rule unreachable due to prior rule {}", j),
                    Some("narrow the earlier rule or reorder"),
                );
                break;
            }
        }
        // 前序中如有 any 或 proto_all 而本条更窄 → Shadowed
        for (j, prev) in acc.iter().enumerate() {
            if prev.any || (prev.proto_all && !s.has_domain && !s.has_cidr) {
                let rid = if with_rule_id {
                    format!(" [{}]", rule_id_of(&r))
                } else {
                    "".into()
                };
                push_warn(
                    issues,
                    IssueCode::ShadowedBy,
                    format!("/route/rules/{}{}", i, rid),
                    format!("rule shadowed by prior rule {}", j),
                    Some("move this rule earlier or restrict domain/cidr"),
                );
                break;
            }
        }
        acc.push(s);
    }
}

// === 布尔归一化模块 (behind feature check-bool) ===
#[cfg(feature = "check-bool")]
mod bool_when {
    use super::*;
    #[cfg(feature = "check-net")]
    use ipnet::IpNet;

    #[derive(Clone, Debug, PartialEq, Eq)]
    pub enum ProtoSet {
        None,
        Tcp,
        Udp,
        Both,
    }
    impl ProtoSet {
        pub fn from_set(s: &std::collections::BTreeSet<String>) -> Self {
            let t = s.contains("tcp");
            let u = s.contains("udp");
            match (t, u) {
                (false, false) => ProtoSet::None,
                (true, false) => ProtoSet::Tcp,
                (false, true) => ProtoSet::Udp,
                (true, true) => ProtoSet::Both,
            }
        }
        pub fn covers(&self, other: &Self) -> bool {
            match (self, other) {
                (ProtoSet::Both, _) => true,
                (a, b) if a == b => true,
                _ => false,
            }
        }
        pub fn is_empty(&self) -> bool {
            matches!(self, ProtoSet::None)
        }
    }

    #[derive(Clone, Debug, Default)]
    pub struct DomSet {
        pub exact: Vec<String>,
        pub suffix: Vec<String>,
    }
    impl DomSet {
        pub fn is_unconstrained(&self) -> bool {
            self.exact.is_empty() && self.suffix.is_empty()
        }
        pub fn is_empty(&self) -> bool {
            false
        } // 目前不支持显式空域，保留
        pub fn covers(&self, other: &Self) -> bool {
            // 复用已有 domain_contains
            super::domain_contains(
                &super::DomPat {
                    exact: self.exact.clone(),
                    suffix: self.suffix.clone(),
                },
                &super::DomPat {
                    exact: other.exact.clone(),
                    suffix: other.suffix.clone(),
                },
            )
        }
    }

    #[derive(Clone, Debug, Default)]
    pub struct CidrSet {
        #[cfg(feature = "check-net")]
        pub nets: Vec<IpNet>,
        pub has_any: bool, // 当未开启 check-net 时，用 has_any 标识"存在 CIDR 限制"
    }
    impl CidrSet {
        pub fn is_unconstrained(&self) -> bool {
            #[cfg(feature = "check-net")]
            {
                self.nets.is_empty()
            }
            #[cfg(not(feature = "check-net"))]
            {
                !self.has_any
            }
        }
        pub fn is_empty(&self) -> bool {
            false
        } // 同上，未来支持差集时再置空
        pub fn covers(&self, other: &Self) -> bool {
            #[cfg(feature = "check-net")]
            {
                super::cidr_contains(&self.nets, &other.nets)
            }
            #[cfg(not(feature = "check-net"))]
            {
                // 没开启网络库时，无法精确比较，退化策略：只在 other 无 CIDR 时返回 true
                !other.has_any
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct BoolWhen {
        pub proto: ProtoSet,
        pub dom: DomSet,
        pub not_dom: DomSet,
        pub cidr: CidrSet,
        pub not_cidr: CidrSet,
        pub not_proto: bool,
    }
    pub fn to_bool_when(w: &super::WhenShape) -> BoolWhen {
        let proto = ProtoSet::from_set(&w.proto_set);
        let dom = DomSet {
            exact: w.dom.exact.clone(),
            suffix: w.dom.suffix.clone(),
        };
        let not_dom = DomSet {
            exact: w.not_dom.exact.clone(),
            suffix: w.not_dom.suffix.clone(),
        };

        #[allow(unused_mut)]
        let mut cidr = CidrSet::default();
        #[allow(unused_mut)]
        let mut not_cidr = CidrSet::default();

        #[cfg(feature = "check-net")]
        {
            cidr.nets = w.cidr.clone();
            not_cidr.nets = w.not_cidr.clone();
        }
        #[cfg(not(feature = "check-net"))]
        {
            cidr.has_any = w.has_cidr;
        }

        BoolWhen {
            proto,
            dom,
            not_dom,
            cidr,
            not_cidr,
            not_proto: w.not_proto,
        }
    }
    /// Check if domain set difference results in empty set
    pub fn diff_empty(dom: &DomSet, not_dom: &DomSet) -> bool {
        // If domain is unconstrained (matches all), negation can't make it empty
        if dom.is_unconstrained() {
            return false;
        }

        // If not_dom is unconstrained, it negates everything
        if not_dom.is_unconstrained() {
            return true;
        }

        // Check if dom \ not_dom = ∅ (set difference is empty)
        // This happens when dom ⊆ not_dom (dom is subset of not_dom)
        dom.covers(not_dom) && !dom.is_unconstrained() && !not_dom.is_unconstrained()
    }

    /// Check if CIDR set difference results in empty set
    pub fn diff_empty_cidr(cidr: &CidrSet, not_cidr: &CidrSet) -> bool {
        // If CIDR is unconstrained (matches all), negation can't make it empty
        if cidr.is_unconstrained() {
            return false;
        }

        // If not_cidr is unconstrained, it negates everything
        if not_cidr.is_unconstrained() {
            return true;
        }

        // Check if cidr \ not_cidr = ∅ (set difference is empty)
        // This happens when cidr ⊆ not_cidr (cidr is subset of not_cidr)
        cidr.covers(not_cidr) && !cidr.is_unconstrained() && !not_cidr.is_unconstrained()
    }

    /// Check if rule becomes empty after applying negation semantics
    pub fn is_empty_after_negation(b: &BoolWhen) -> (bool, &'static str) {
        // Protocol negation check: if not_proto is true and proto is not empty,
        // then we're negating a specific protocol set, which results in empty match
        if b.not_proto && !b.proto.is_empty() {
            return (true, "proto_neg");
        }

        // Domain set difference check: dom \ not_dom = ∅
        if diff_empty(&b.dom, &b.not_dom) {
            return (true, "domain_neg");
        }

        // CIDR set difference check: cidr \ not_cidr = ∅
        if diff_empty_cidr(&b.cidr, &b.not_cidr) {
            return (true, "cidr_neg");
        }

        (false, "")
    }

    pub fn is_empty(b: &BoolWhen) -> (bool, &'static str) {
        if b.proto.is_empty() {
            return (true, "proto");
        }

        // Check for negation-based conflicts using true set difference semantics
        let (empty_after_neg, reason) = is_empty_after_negation(b);
        if empty_after_neg {
            return (true, reason);
        }

        if b.dom.is_empty() {
            return (true, "domain");
        }
        if b.cidr.is_empty() {
            return (true, "cidr");
        }

        (false, "")
    }
    pub fn covers(a: &BoolWhen, b: &BoolWhen) -> (bool, &'static str) {
        if !a.proto.covers(&b.proto) {
            return (false, "proto");
        }
        if !a.dom.covers(&b.dom) {
            return (false, "domain");
        }
        if !a.cidr.covers(&b.cidr) {
            return (false, "cidr");
        }
        (true, "all")
    }
}

fn analyze_boolean_semantics(
    root: &Value,
    issues: &mut Vec<CheckIssue>,
    why: bool,
    graph: bool,
    with_rule_id: bool,
) -> Option<String> {
    #[cfg(not(feature = "check-bool"))]
    {
        let _ = (root, issues, why, graph, with_rule_id);
        return None;
    }
    #[cfg(feature = "check-bool")]
    let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) else {
        return None;
    };
    #[cfg(feature = "check-bool")]
    {
        use bool_when::*;
        let mut edges: Vec<(usize, usize, &'static str)> = Vec::new();
        let mut seen: Vec<BoolWhen> = Vec::new();
        for (i, r) in rules.iter().enumerate() {
            let when = r
                .get("when")
                .cloned()
                .unwrap_or(Value::Object(serde_json::Map::new()));
            let ws = shape_of_when(&when);
            let bw = to_bool_when(&ws);
            if let (true, dim) = is_empty(&bw) {
                let code = if dim.ends_with("_neg") {
                    IssueCode::ConflictingRule
                } else {
                    IssueCode::EmptyRuleMatch
                };
                let hint = if why {
                    Some(format!("empty on {}", dim))
                } else {
                    None
                };
                let rid = if with_rule_id {
                    format!(" [{}]", rule_id_of(&r))
                } else {
                    "".into()
                };
                push_err(
                    issues,
                    code,
                    format!("/route/rules/{}{}", i, rid),
                    "rule matches empty traffic",
                    hint.as_deref(),
                );
            }
            // 冗余/覆盖
            for (j, prev) in seen.iter().enumerate() {
                let (cov, dim) = covers(prev, &bw);
                if cov {
                    edges.push((j, i, "covers"));
                    let hint = if why {
                        Some(format!("covered on {}", dim))
                    } else {
                        None
                    };
                    let rid = if with_rule_id {
                        format!(" [{}]", rule_id_of(&r))
                    } else {
                        "".into()
                    };
                    push_warn(
                        issues,
                        IssueCode::RedundantRule,
                        format!("/route/rules/{}{}", i, rid),
                        format!("rule fully covered by prior rule {}", j),
                        hint.as_deref(),
                    );
                    break;
                }
            }
            // 记录
            seen.push(bw);
        }
        if graph {
            // 输出 DOT
            let mut dot = String::from("digraph rules {\n  rankdir=LR;\n");
            if with_rule_id {
                for (j, i, lab) in edges {
                    let rid_j = rule_id_of(&rules[j]);
                    let rid_i = rule_id_of(&rules[i]);
                    dot.push_str(&format!(
                        "  \"r{}-{}\" -> \"r{}-{}\" [label=\"{}\"];\n",
                        j, rid_j, i, rid_i, lab
                    ));
                }
            } else {
                for (j, i, lab) in edges {
                    dot.push_str(&format!("  r{} -> r{} [label=\"{}\"];\n", j, i, lab));
                }
            }
            dot.push_str("}\n");
            return Some(dot);
        }
        None
    }
}

// === 指纹：规范化 JSON（对象键排序），输出 sha256 与规范化文本 ===
fn canonicalize(v: &Value) -> Value {
    match v {
        Value::Object(map) => {
            let mut out = serde_json::Map::new();
            for k in {
                let mut ks: Vec<_> = map.keys().cloned().collect();
                ks.sort();
                ks
            } {
                out.insert(k.clone(), canonicalize(&map[&k]));
            }
            Value::Object(out)
        }
        Value::Array(arr) => Value::Array(arr.iter().map(canonicalize).collect()),
        _ => v.clone(),
    }
}

fn sha256_hex(bytes: &[u8]) -> String {
    use sha2::{Digest, Sha256};
    let mut h = Sha256::new();
    h.update(bytes);
    let d = h.finalize();
    d.iter().map(|b| format!("{:02x}", b)).collect::<String>()
}

fn rule_id_of(rule: &serde_json::Value) -> String {
    use sha2::{Digest, Sha256};
    // 仅针对 when+to 计算；保证重排无关
    let mut m = serde_json::Map::new();
    if let Some(w) = rule.get("when") {
        m.insert("when".into(), canonicalize(w));
    }
    if let Some(t) = rule.get("to") {
        m.insert("to".into(), canonicalize(t));
    }
    let s = serde_json::Value::Object(m);
    let mut hasher = Sha256::new();
    hasher.update(serde_json::to_vec(&s).unwrap());
    let h = hasher.finalize();
    format!("{:x}", &h)[0..8].to_string()
}

fn attach_rule_ids(root: &serde_json::Value) -> Vec<String> {
    let mut ids = Vec::new();
    if let Some(rules) = root.pointer("/route/rules").and_then(|x| x.as_array()) {
        for r in rules {
            ids.push(rule_id_of(r));
        }
    }
    ids
}

/// When ptr points to /route/rules/N (or deeper), compute sha8 for that rule
fn try_rule_id_for_ptr(cfg: &serde_json::Value, ptr: &str) -> Option<String> {
    let prefix = "/route/rules/";
    if !ptr.starts_with(prefix) {
        return None;
    }
    let rest = &ptr[prefix.len()..];
    let head = rest.split('/').next().unwrap_or("");
    // strip optional trailing annotation like " [deadbeef]"
    let head_clean = head.split_whitespace().next().unwrap_or(head);
    let idx: usize = head_clean.parse().ok()?;
    let rules = cfg.pointer("/route/rules")?.as_array()?;
    let rule = rules.get(idx)?;
    Some(rule_id_of(rule))
}

fn diff_config_by_rule(old: &serde_json::Value, new: &serde_json::Value) -> serde_json::Value {
    use std::collections::BTreeSet;
    let o = attach_rule_ids(old);
    let n = attach_rule_ids(new);
    let so: BTreeSet<_> = o.iter().cloned().collect();
    let sn: BTreeSet<_> = n.iter().cloned().collect();
    let added: Vec<_> = sn.difference(&so).cloned().collect();
    let removed: Vec<_> = so.difference(&sn).cloned().collect();
    let moved: Vec<_> = o
        .iter()
        .enumerate()
        .filter_map(|(i, id)| {
            n.iter()
                .position(|x| x == id)
                .filter(|j| *j != i)
                .map(|j| format!("{}:{}->{}", id, i, j))
        })
        .collect();
    serde_json::json!({ "added": added, "removed": removed, "moved": moved })
}

fn load_config(path: &PathBuf) -> anyhow::Result<Value> {
    let raw = if path.as_os_str() == "-" {
        use std::io::{self, Read};
        let mut buf = String::new();
        io::stdin().read_to_string(&mut buf)?;
        buf
    } else {
        fs::read_to_string(path)?
    };
    // try yaml first (superset); fallback to json
    let val: Value = match serde_yaml::from_str::<Value>(&raw) {
        Ok(v) => v,
        Err(_) => serde_json::from_str(&raw)?,
    };
    Ok(val)
}

#[cfg(any(feature = "sbcore_analyze_json", feature = "check-schema"))]
fn check_enhanced_rule_analysis(root: &Value, issues: &mut Vec<CheckIssue>, inject_ruleid: bool) {
    use sb_core::router::analyze::analyze_rules;

    let view = build_normalized_view(root);
    if let Some(view) = view {
        let level = std::env::var("SB_CHECK_ANALYZE_LEVEL").unwrap_or_else(|_| "error".into());
        let analyze_issues = analyze_rules(&view);
        for mut issue in analyze_issues {
            if inject_ruleid {
                if let Some(rule_id) = try_rule_id_for_ptr(root, &issue.ptr) {
                    issue.rule_id = Some(rule_id);
                }
            }
            let (code, kind) = match issue.code {
                "ConflictRule" => {
                    if level == "warn" {
                        (IssueCode::ConflictingRule, IssueKind::Warning)
                    } else {
                        (IssueCode::ConflictingRule, IssueKind::Error)
                    }
                }
                "ConflictRuleGroup" => {
                    if level == "warn" {
                        (IssueCode::ConflictingRule, IssueKind::Warning)
                    } else {
                        (IssueCode::ConflictingRule, IssueKind::Error)
                    }
                }
                "UnreachableOutbound" => (IssueCode::UnreachableRule, IssueKind::Error),
                "UnreachableOutboundGroup" => (IssueCode::UnreachableRule, IssueKind::Error),
                _ => (IssueCode::ConflictingRule, IssueKind::Warning), // fallback
            };
            issues.push(CheckIssue {
                kind,
                code,
                ptr: issue.ptr,
                msg: issue.msg,
                hint: None,
                rule_id: issue.rule_id,
                key: issue.key,
                members: issue.members,
                tos: issue.tos,
                risk: issue.risk,
            });
        }
    }
}

fn build_normalized_view(root: &Value) -> Option<Value> {
    // This is a simplified version that builds a normalized view
    // In a real implementation, this might be more complex
    if let Some(rules) = root.get("route").and_then(|r| r.get("rules")) {
        if let Some(outbounds) = root.get("outbounds") {
            return Some(serde_json::json!({
                "route": { "rules": rules },
                "outbounds": outbounds
            }));
        }
    }
    None
}

pub fn run(args: CheckArgs) -> Result<()> {
    let data = fs::read(&args.config)
        .with_context(|| format!("read config {}", &args.config))?;
    let raw: serde_json::Value = serde_json::from_slice(&data)
        .with_context(|| "parse as json")?;

    // 1) v2 校验（如启用）
    if args.schema_v2 {
        let issues = v2::validate_v2(&raw);
        if !issues.is_empty() {
            if args.format == "json" {
                print_json_issues(issues);
            } else {
                eprintln!("schema-v2 validation failed; issues={}", issues.len());
            }
            std::process::exit(2);
        }
    }

    // 2) v1->IR 规范化/最小化（守门）
    let mut ir: ConfigIR = to_ir_v1(&raw);
    let mut issues = Vec::<serde_json::Value>::new();
    if args.minimize {
        match minimize_config(&mut ir) {
            MinimizeAction::SkippedByNegation => {
                let diag = "MINIMIZE_SKIPPED: negation-detected (contains not_*) -> canonicalize-only";
                let _ = writeln!(&mut std::io::stderr(), "{diag}");
                issues.push(json!({
                    "kind":"warning",
                    "code": IssueCode::MinimizeSkippedByNegation.as_str(),
                    "ptr":"/route/rules",
                    "msg":"negation detected; minimize degraded to canonicalize-only",
                    "hint":"remove not_* to enable rule deletion"
                }));
            }
            MinimizeAction::Applied => {}
        }
    } else {
        normalize_config(&mut ir);
    }

    // 3) 输出写入（如指定）
    if args.write_normalized {
        let out = args.out.clone().unwrap_or_else(|| {
            let p = Path::new(&args.config);
            let stem = p.file_stem().and_then(|s| s.to_str()).unwrap_or("config");
            let parent = p.parent().unwrap_or_else(|| Path::new("."));
            parent.join(format!("{}.normalized.json", stem)).to_string_lossy().to_string()
        });
        let text = serde_json::to_string_pretty(&ir).unwrap();
        fs::write(&out, text).with_context(|| format!("write {}", out))?;
    }

    // 4) Schema dump if requested
    if args.schema && !args.schema_dump.is_empty() {
        match args.schema_dump.as_str() {
            "v1" => {
                println!("{}", serde_json::to_string_pretty(&schema_v1()).unwrap());
            }
            "v2" => {
                #[cfg(feature = "schema-v2")]
                {
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&sb_core::config::schema_v2::schema_v2())
                            .unwrap()
                    );
                }
                #[cfg(not(feature = "schema-v2"))]
                {
                    eprintln!("schema v2 not available (build without feature)");
                    return Ok(2);
                }
            }
            _ => {}
        }
        return Ok(0);
    }

    if !args.diff_config.is_empty() {
        if args.diff_config.len() != 2 {
            eprintln!("--diff-config OLD NEW");
            return Ok(2);
        }
        let oldc = load_config(&PathBuf::from(&args.diff_config[0]))?;
        let newc = load_config(&PathBuf::from(&args.diff_config[1]))?;
        let o = canonicalize(&oldc);
        let n = canonicalize(&newc);
        let d = diff_config_by_rule(&o, &n);
        println!("{}", serde_json::to_string_pretty(&d).unwrap());
        return Ok(0);
    }

    let config_path = args
        .config
        .as_ref()
        .ok_or_else(|| anyhow::anyhow!("config file is required"))?;
    let v = load_config(&config_path).map_err(|e| anyhow::anyhow!("failed to read config: {e}"))?;
    let mut issues: Vec<CheckIssue> = Vec::new();

    // Check feature availability and emit warnings for disabled features
    check_feature_availability(&args, &mut issues);

    // apiVersion/kind soft check (can be upgraded to strict)
    if args.enforce_apiversion {
        let ap = v.get("apiVersion").and_then(|x| x.as_str());
        let kd = v.get("kind").and_then(|x| x.as_str());
        if ap.is_none() {
            push_warn(
                &mut issues,
                IssueCode::ApiVersionMissing,
                "/apiVersion",
                "missing apiVersion",
                Some("set to 'singbox/v1'"),
            );
        } else if !matches!(ap.unwrap(), "singbox/v1") {
            push_warn(
                &mut issues,
                IssueCode::ApiVersionUnknown,
                "/apiVersion",
                "unknown apiVersion",
                Some("supported: singbox/v1"),
            );
        }
        if kd.is_none() {
            push_warn(
                &mut issues,
                IssueCode::KindMissing,
                "/kind",
                "missing kind",
                Some("set to 'Config'"),
            );
        }
    }

    // Schema v2 validation (optional, behind feature flag)
    // Automatic v2 validation when --deny-unknown flag is used
    let should_validate_v2 = args.schema_v2_validate || args.deny_unknown;

    if should_validate_v2 {
        validate_schema_v2(&v, &mut issues);
    }

    check_inbounds(&v, &mut issues);
    check_outbounds(&v, &mut issues);
    check_dns(&v, &mut issues);
    check_route(&v, &mut issues);
    check_rules_mutex(&v, &mut issues);

    #[cfg(feature = "check-schema")]
    if args.schema {
        let compiled = JSONSchema::options()
            .with_draft(Draft::Draft7)
            .compile(&schema_v1_with_strict(args.deny_unknown))
            .map_err(|e| anyhow::anyhow!("invalid internal schema: {e}"))?;
        let result = compiled.validate(&v);
        if let Err(errors) = result {
            for e in errors {
                let p = e.instance_path.to_string(); // e.g. "/dns/mode"
                let msg = e.to_string();
                push_err(&mut issues, IssueCode::SchemaViolation, p, msg, None);
            }
        }
    }

    if args.check_refs {
        check_refs(&v, &args, &mut issues);
    }
    // Cross-reference validation (no IO needed)
    check_cross_refs(&v, &mut issues);
    // Name duplication/port conflicts
    check_names_and_ports(&v, &mut issues);
    // CIDR/domain semantics
    check_rule_semantics(&v, &mut issues);

    // Inject rule_id into issues when requested via env (move up for use in enhanced analysis)
    let inject_ruleid = std::env::var("SB_CHECK_RULEID").ok().as_deref() == Some("1");

    // Rule coverage analysis
    analyze_rule_coverage(&v, &mut issues, args.with_rule_id);
    // Enhanced rule analysis (behind env)
    #[cfg(any(feature = "sbcore_analyze_json", feature = "check-schema"))]
    if std::env::var("SB_CHECK_ANALYZE").ok().as_deref() == Some("1") {
        check_enhanced_rule_analysis(&v, &mut issues, inject_ruleid);
    }
    // Boolean semantics analysis
    if args.explain_why || args.rule_graph {
        if let Some(dot) = analyze_boolean_semantics(
            &v,
            &mut issues,
            args.explain_why,
            args.rule_graph,
            args.with_rule_id,
        ) {
            if args.rule_graph {
                println!("{}", dot);
                return Ok(0);
            }
        }
    }
    // Unknown fields with allow whitelist
    let allow_list: Vec<String> = args
        .allow_unknown
        .as_deref()
        .unwrap_or("")
        .split(',')
        .filter(|s| !s.is_empty())
        .map(|s| s.trim().to_string())
        .collect();
    collect_unknown_fields(&v, args.deny_unknown, &allow_list, &mut issues);

    #[cfg(feature = "config_guard")]
    if std::env::var("SB_CHECK_GUARD").ok().as_deref() == Some("1") {
        append_config_risks(&v, &mut issues);
    }

    // Summary first (if requested)
    if args.summary {
        print_summary(&v);
    }
    if inject_ruleid {
        for it in &mut issues {
            if it.rule_id.is_none() {
                it.rule_id = try_rule_id_for_ptr(&v, &it.ptr);
            }
        }
    }

    // Early exit for minimize-rules mode
    if args.minimize_rules {
        // 守门：一旦存在任何 not_* 维度，降级为"只规范化/不删"
        let config_bytes = serde_json::to_vec(&v).unwrap_or_default();
        let has_neg = sb_config::rule::negation::has_any_negation(&config_bytes);
        if has_neg {
            // 仅做规范化，禁止删除；写出诊断（stderr 可读 & 机器可读）
            let diag = "MINIMIZE_SKIPPED: negation-detected (contains not_*) -> canonicalize-only";
            let _ = writeln!(&mut std::io::stderr(), "{diag}");
            if args.format == "json" {
                let issues = vec![json!({
                    "kind":"warning",
                    "code":"MinimizeSkippedByNegation",
                    "ptr":"/route/rules",
                    "msg":"negation detected; minimize degraded to canonicalize-only",
                    "hint":"remove not_* to enable rule deletion",
                    "fingerprint": env!("CARGO_PKG_VERSION")
                })];
                let obj = json!({
                    "issues": issues,
                    "fingerprint": env!("CARGO_PKG_VERSION")
                });
                println!("{}", serde_json::to_string_pretty(&obj).unwrap());
            } else {
                let canon = canonicalize(&v);
                println!("{}", serde_json::to_string_pretty(&canon).unwrap());
            }
            return Ok(0);
        }
        let m = minimize_rules(&v);
        println!("{}", serde_json::to_string_pretty(&m).unwrap());
        return Ok(0);
    }

    // Early exit for apply-plan mode
    if args.apply_plan {
        // Read plan from stdin (JSON array)
        use std::io::Read;
        let mut buf = String::new();
        std::io::stdin().read_to_string(&mut buf)?;
        let plan: Vec<serde_json::Value> = serde_json::from_str(&buf).unwrap_or_default();
        let patched = apply_plan_to(&v, &plan);
        println!("{}", serde_json::to_string_pretty(&patched).unwrap());
        return Ok(0);
    }

    // Early exit for normalize mode
    if args.normalize {
        let norm = normalize_config(&v);
        println!("{}", serde_json::to_string_pretty(&norm).unwrap());
        return Ok(0);
    }

    // Early exit for autofix plan mode
    if args.autofix_plan {
        let ops = build_autofix_plan(&v);
        let j = serde_json::to_string_pretty(&ops).unwrap();
        println!("{}", j);
        return Ok(if ops.is_empty() { 0 } else { 1 }); // 有计划→非零，提示需要应用
    }

    // Early exit for negation suggestion mode
    if args.autofix_suggest_negation {
        let suggestions = suggest_negation_fixes(&v);
        let j = serde_json::to_string_pretty(&suggestions).unwrap();
        println!("{}", j);
        return Ok(if suggestions.is_empty() { 0 } else { 1 }); // 有建议→非零，提示有可改进项
    }

    // 指纹（可选）
    let (canon_json, fp_hex) = if args.fingerprint {
        let canon = canonicalize(&v);
        let text = serde_json::to_vec(&canon).unwrap();
        let hex = sha256_hex(&text);
        (Some(canon), Some(hex))
    } else {
        (None, None)
    };

    // summarize
    let errs = issues
        .iter()
        .filter(|i| matches!(i.kind, IssueKind::Error))
        .count();
    let warns = issues
        .iter()
        .filter(|i| matches!(i.kind, IssueKind::Warning))
        .count();
    let ok = if args.strict {
        errs == 0 && warns == 0
    } else {
        errs == 0
    };
    let report = CheckReport {
        ok,
        file: config_path.to_string_lossy().to_string(),
        issues: issues.clone(),
        summary: json!({ "errors": errs, "warnings": warns, "strict": args.strict }),
        fingerprint: fp_hex,
        canonical: canon_json,
    };
    match args.format.as_str() {
        "json" => {
            println!("{}", serde_json::to_string_pretty(&report).unwrap());
        }
        "sarif" => {
            println!("{}", to_sarif(&report));
        }
        _ => {
            if ok {
                println!("OK: {}", report.file);
            } else {
                eprintln!("BAD: {}", report.file);
            }
            if let Some(fp) = report.fingerprint.as_ref() {
                println!("FP: sha256={}", fp);
            }
            for it in issues {
                let k = match it.kind {
                    IssueKind::Error => "E",
                    _ => "W",
                };
                let hint = if args.explain {
                    it.hint.clone().or_else(|| hint_for(&it.code, &it.ptr))
                } else {
                    it.hint.clone()
                };
                if let Some(h) = hint.as_ref() {
                    eprintln!(
                        "[{}][{:?}] {}: {}  (hint: {})",
                        k, it.code, it.ptr, it.msg, h
                    );
                } else {
                    eprintln!("[{}][{:?}] {}: {}", k, it.code, it.ptr, it.msg);
                }
            }
        }
    }
    Ok(if ok { 0 } else { 1 })
}

fn to_sarif(rep: &CheckReport) -> String {
    // 最小 SARIF 2.1.0 适配：每个 issue -> result；code 作为 ruleId
    use serde_json::json;
    let results: Vec<Value> = rep
        .issues
        .iter()
        .map(|i| {
            let level = match i.kind {
                IssueKind::Error => "error",
                IssueKind::Warning => "warning",
            };
            json!({
                "ruleId": format!("{:?}", i.code),
                "level": level,
                "message": { "text": format!("{} ({})", i.msg, i.ptr) },
                "locations": [{
                    "physicalLocation": {
                        "artifactLocation": { "uri": rep.file },
                        "region": { "message": { "text": i.ptr } }
                    }
                }]
            })
        })
        .collect();
    let sarif = json!({
        "version": "2.1.0",
        "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
        "runs": [{
            "tool": {
                "driver": {
                    "name": "singbox-rust-check",
                    "informationUri": "https://example.invalid/singbox-rust",
                    "rules": []
                }
            },
            "results": results
        }]
    });
    serde_json::to_string_pretty(&sarif).unwrap()
}
